{
  "version": 3,
  "sources": ["../../markdown-it-front-matter/index.js"],
  "sourcesContent": ["// Process front matter and pass to cb\n'use strict';\n\nmodule.exports = function front_matter_plugin(md, cb) {\n  var min_markers = 3,\n      marker_str  = '-',\n      marker_char = marker_str.charCodeAt(0),\n      marker_len  = marker_str.length;\n\n  function frontMatter(state, startLine, endLine, silent) {\n    var pos,\n        nextLine,\n        marker_count,\n        token,\n        old_parent,\n        old_line_max,\n        start_content,\n        auto_closed = false,\n        start = state.bMarks[startLine] + state.tShift[startLine],\n        max = state.eMarks[startLine];\n\n    // Check out the first character of the first line quickly,\n    // this should filter out non-front matter\n    if (startLine !== 0 || marker_char !== state.src.charCodeAt(0)) {\n      return false;\n    }\n\n    // Check out the rest of the marker string\n    // while pos <= 3\n    for (pos = start + 1; pos <= max; pos++) {\n      if (marker_str[(pos - start) % marker_len] !== state.src[pos]) {\n        start_content = pos + 1;\n        break;\n      }\n    }\n\n    marker_count = Math.floor((pos - start) / marker_len);\n\n    if (marker_count < min_markers) {\n      return false;\n    }\n    pos -= (pos - start) % marker_len;\n\n    // Since start is found, we can report success here in validation mode\n    if (silent) {\n      return true;\n    }\n\n    // Search for the end of the block\n    nextLine = startLine;\n\n    for (;;) {\n      nextLine++;\n      if (nextLine >= endLine) {\n        // unclosed block should be autoclosed by end of document.\n        // also block seems to be autoclosed by end of parent\n        break;\n      }\n\n      if (state.src.slice(start, max) === '...') {\n        break;\n      }\n\n      start = state.bMarks[nextLine] + state.tShift[nextLine];\n      max = state.eMarks[nextLine];\n\n      if (start < max && state.sCount[nextLine] < state.blkIndent) {\n        // non-empty line with negative indent should stop the list:\n        // - ```\n        //  test\n        break;\n      }\n\n      if (marker_char !== state.src.charCodeAt(start)) {\n        continue;\n      }\n\n      if (state.sCount[nextLine] - state.blkIndent >= 4) {\n        // closing fence should be indented less than 4 spaces\n        continue;\n      }\n\n      for (pos = start + 1; pos <= max; pos++) {\n        if (marker_str[(pos - start) % marker_len] !== state.src[pos]) {\n          break;\n        }\n      }\n\n      // closing code fence must be at least as long as the opening one\n      if (Math.floor((pos - start) / marker_len) < marker_count) {\n        continue;\n      }\n\n      // make sure tail has spaces only\n      pos -= (pos - start) % marker_len;\n      pos = state.skipSpaces(pos);\n\n      if (pos < max) {\n        continue;\n      }\n\n      // found!\n      auto_closed = true;\n      break;\n    }\n\n    old_parent = state.parentType;\n    old_line_max = state.lineMax;\n    state.parentType = 'container';\n\n    // this will prevent lazy continuations from ever going past our end marker\n    state.lineMax = nextLine;\n\n    token        = state.push('front_matter', null, 0);\n    token.hidden = true;\n    token.markup = state.src.slice(startLine, pos);\n    token.block  = true;\n    token.map    = [ startLine, pos ];\n    token.meta   = state.src.slice(start_content, start - 1);\n\n    state.parentType = old_parent;\n    state.lineMax = old_line_max;\n    state.line = nextLine + (auto_closed ? 1 : 0);\n\n    cb(token.meta);\n\n    return true;\n  }\n\n  md.block.ruler.before(\n    'table',\n    'front_matter',\n    frontMatter,\n    {\n      alt: [\n        'paragraph',\n        'reference',\n        'blockquote',\n        'list' \n      ]\n    }\n  );\n};\n"],
  "mappings": ";;;;;AAAA;AAAA;AAGA,WAAO,UAAU,SAAS,oBAAoB,IAAI,IAAI;AACpD,UAAI,cAAc,GACd,aAAc,KACd,cAAc,WAAW,WAAW,CAAC,GACrC,aAAc,WAAW;AAE7B,eAAS,YAAY,OAAO,WAAW,SAAS,QAAQ;AACtD,YAAI,KACA,UACA,cACA,OACA,YACA,cACA,eACA,cAAc,OACd,QAAQ,MAAM,OAAO,SAAS,IAAI,MAAM,OAAO,SAAS,GACxD,MAAM,MAAM,OAAO,SAAS;AAIhC,YAAI,cAAc,KAAK,gBAAgB,MAAM,IAAI,WAAW,CAAC,GAAG;AAC9D,iBAAO;AAAA,QACT;AAIA,aAAK,MAAM,QAAQ,GAAG,OAAO,KAAK,OAAO;AACvC,cAAI,YAAY,MAAM,SAAS,UAAU,MAAM,MAAM,IAAI,GAAG,GAAG;AAC7D,4BAAgB,MAAM;AACtB;AAAA,UACF;AAAA,QACF;AAEA,uBAAe,KAAK,OAAO,MAAM,SAAS,UAAU;AAEpD,YAAI,eAAe,aAAa;AAC9B,iBAAO;AAAA,QACT;AACA,gBAAQ,MAAM,SAAS;AAGvB,YAAI,QAAQ;AACV,iBAAO;AAAA,QACT;AAGA,mBAAW;AAEX,mBAAS;AACP;AACA,cAAI,YAAY,SAAS;AAGvB;AAAA,UACF;AAEA,cAAI,MAAM,IAAI,MAAM,OAAO,GAAG,MAAM,OAAO;AACzC;AAAA,UACF;AAEA,kBAAQ,MAAM,OAAO,QAAQ,IAAI,MAAM,OAAO,QAAQ;AACtD,gBAAM,MAAM,OAAO,QAAQ;AAE3B,cAAI,QAAQ,OAAO,MAAM,OAAO,QAAQ,IAAI,MAAM,WAAW;AAI3D;AAAA,UACF;AAEA,cAAI,gBAAgB,MAAM,IAAI,WAAW,KAAK,GAAG;AAC/C;AAAA,UACF;AAEA,cAAI,MAAM,OAAO,QAAQ,IAAI,MAAM,aAAa,GAAG;AAEjD;AAAA,UACF;AAEA,eAAK,MAAM,QAAQ,GAAG,OAAO,KAAK,OAAO;AACvC,gBAAI,YAAY,MAAM,SAAS,UAAU,MAAM,MAAM,IAAI,GAAG,GAAG;AAC7D;AAAA,YACF;AAAA,UACF;AAGA,cAAI,KAAK,OAAO,MAAM,SAAS,UAAU,IAAI,cAAc;AACzD;AAAA,UACF;AAGA,kBAAQ,MAAM,SAAS;AACvB,gBAAM,MAAM,WAAW,GAAG;AAE1B,cAAI,MAAM,KAAK;AACb;AAAA,UACF;AAGA,wBAAc;AACd;AAAA,QACF;AAEA,qBAAa,MAAM;AACnB,uBAAe,MAAM;AACrB,cAAM,aAAa;AAGnB,cAAM,UAAU;AAEhB,gBAAe,MAAM,KAAK,gBAAgB,MAAM,CAAC;AACjD,cAAM,SAAS;AACf,cAAM,SAAS,MAAM,IAAI,MAAM,WAAW,GAAG;AAC7C,cAAM,QAAS;AACf,cAAM,MAAS,CAAE,WAAW,GAAI;AAChC,cAAM,OAAS,MAAM,IAAI,MAAM,eAAe,QAAQ,CAAC;AAEvD,cAAM,aAAa;AACnB,cAAM,UAAU;AAChB,cAAM,OAAO,YAAY,cAAc,IAAI;AAE3C,WAAG,MAAM,IAAI;AAEb,eAAO;AAAA,MACT;AAEA,SAAG,MAAM,MAAM;AAAA,QACb;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,UACE,KAAK;AAAA,YACH;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,UACF;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAAA;AAAA;",
  "names": []
}
